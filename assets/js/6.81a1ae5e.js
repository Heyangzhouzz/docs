(window.webpackJsonp=window.webpackJsonp||[]).push([[6],{189:function(t,a,r){"use strict";r.r(a);var s=r(0),e=Object(s.a)({},function(){var t=this,a=t.$createElement,r=t._self._c||a;return r("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[r("h1",{attrs:{id:"概述"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#概述","aria-hidden":"true"}},[t._v("#")]),t._v(" 概述")]),t._v(" "),r("h2",{attrs:{id:"什么是组件化"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#什么是组件化","aria-hidden":"true"}},[t._v("#")]),t._v(" 什么是组件化")]),t._v(" "),r("p",[t._v("组件化并不是前端所特有的，一些其他的语言或者桌面程序等，都具有组件化的先例。确切的说，只要有UI层的展示，就必定有可以组件化的地方。简单来说，"),r("b",[t._v("组件就是将一段UI样式和其对应的功能作为独立的整体去看待，无论这个整体放在哪里去使用，它都具有一样的功能和样式，从而实现复用，这种整体化的细想就是组件化。")]),t._v("不难看出，组件化设计就是为了增加复用性，灵活性，提高系统设计，从而提高开发效率。")]),t._v(" "),r("h2",{attrs:{id:"组件的分类"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#组件的分类","aria-hidden":"true"}},[t._v("#")]),t._v(" 组件的分类")]),t._v(" "),r("ol",[r("li",[r("strong",[t._v("通用型组件")])]),t._v(" "),r("li",[r("strong",[t._v("业务型组件")])]),t._v(" "),r("li",[r("strong",[t._v("路由组件")])])]),t._v(" "),r("h2",{attrs:{id:"组件的特征"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#组件的特征","aria-hidden":"true"}},[t._v("#")]),t._v(" 组件的特征")]),t._v(" "),r("ol",[r("li",[r("strong",[t._v("由内部的状态(state,data)和外部属性构成(props)")])]),t._v(" "),r("li",[r("strong",[t._v("组件是一个纯函数(props 是只读的)")])]),t._v(" "),r("li",[r("strong",[t._v("单向数据流，数据只能由父级传入，受控因素由父级决定。")])])]),t._v(" "),r("div",{staticClass:"tip custom-block"},[r("p",[r("strong",[t._v("纯函数")]),r("br"),t._v("\n一个函数的返回结果只依赖于它的参数，并且在执行过程里面没有副作用，我们就把这个函数叫做纯函数。")])])])},[],!1,null,null,null);a.default=e.exports}}]);